<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QBICE - Query-Based Incremental Computation Engine</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-bb82a940.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-40332333.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">QBICE - Query-Based Incremental Computation Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/Simmypeet/qbice" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the QBICE (Query-Based Incremental Computation Engine) book! This guide will teach you how to build efficient incremental computation systems using QBICE.</p>
<h2 id="what-is-qbice"><a class="header" href="#what-is-qbice">What is QBICE?</a></h2>
<p>QBICE is a high-performance, asynchronous incremental computation framework for Rust. It allows you to define computations as a graph of queries, where changes to inputs automatically propagate through the system—recomputing only what’s necessary.</p>
<h2 id="why-incremental-computation"><a class="header" href="#why-incremental-computation">Why Incremental Computation?</a></h2>
<p>Consider a compiler that needs to type-check a large codebase. When a developer changes a single file, recompiling everything from scratch would be wasteful. Instead, an incremental system:</p>
<ol>
<li><strong>Tracks dependencies</strong> - Knows which computations depend on the changed file</li>
<li><strong>Invalidates selectively</strong> - Marks only affected computations as needing updates</li>
<li><strong>Recomputes minimally</strong> - Recalculates only what’s necessary</li>
</ol>
<p>This approach can reduce compilation times from minutes to seconds.</p>
<h2 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h2>
<ul>
<li><strong>Automatic Dependency Tracking</strong> - QBICE automatically records which queries depend on which others</li>
<li><strong>Minimal Recomputation</strong> - Only recomputes queries whose inputs have changed</li>
<li><strong>Async-First</strong> - Built on Tokio for efficient concurrent execution</li>
<li><strong>Persistent</strong> - Query results survive program restarts</li>
</ul>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>QBICE is ideal for scenarios where:</p>
<ul>
<li>Computations are expensive relative to cache lookups</li>
<li>Inputs change incrementally</li>
<li>You want to avoid redundant recomputation</li>
<li>You need fine-grained dependency tracking</li>
</ul>
<p>Common applications include:</p>
<ul>
<li><strong>Compilers</strong> - Incremental compilation and analysis</li>
<li><strong>Build Systems</strong> - Smart rebuilding of artifacts</li>
<li><strong>IDEs</strong> - Real-time code analysis and diagnostics</li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior Art</a></h2>
<p>QBICE builds on decades of research and practical work in incremental computation. Understanding these foundational systems helps appreciate QBICE’s design choices.</p>
<h3 id="adapton"><a class="header" href="#adapton">Adapton</a></h3>
<p><a href="https://github.com/adapton">Adapton</a> is a pioneering research that introduced many core concepts used in QBICE:</p>
<ul>
<li><strong>Demanded Computation Graphs (DCG)</strong> - The idea that computations form a graph where dependencies are tracked automatically</li>
<li><strong>Dirty Propagation</strong> - Marking dependency edges as dirty when inputs change</li>
</ul>
<p>The SafeDivide example in the tutorial is adapted from Adapton’s classic examples, demonstrating how incremental computation handles error cases elegantly.</p>
<h3 id="salsa"><a class="header" href="#salsa">Salsa</a></h3>
<p><a href="https://github.com/salsa-rs/salsa">Salsa</a> is a Rust framework for incremental computation used in rust-analyzer. It provides:</p>
<ul>
<li>Query-based incremental computation</li>
<li>Automatic dependency tracking</li>
</ul>
<p>QBICE shares similar goals but differs in:</p>
<ul>
<li><strong>Fine-Grained Invalidation</strong>: Salsa uses timestamp based to determine whether
the query needs to be reverified, while QBICE uses fine-grained dirty
propagation through dependency edges.</li>
<li><strong>Optimizations</strong>: Salsa achieves optimized graph traversal through the
conceopt of durability, while QBICE provides firewall and projection queries
to optimize dirty propagation and recomputation.</li>
</ul>
<h2 id="how-this-book-is-organized"><a class="header" href="#how-this-book-is-organized">How This Book Is Organized</a></h2>
<p>This book is divided into three main sections:</p>
<h3 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h3>
<p>A hands-on guide that walks you through building your first QBICE application. You’ll learn the fundamentals by creating a simple calculator that performs incremental computation.</p>
<h3 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h3>
<p>Deep dives into optimization techniques like firewall queries, projection queries, and performance tuning strategies.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>This book assumes you’re familiar with:</p>
<ul>
<li><strong>Rust</strong> - Basic to intermediate knowledge</li>
<li><strong>Async/Await</strong> - Understanding of async Rust and Tokio</li>
<li><strong>Traits</strong> - How Rust traits work</li>
</ul>
<p>If you’re new to these topics, we recommend:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a></li>
<li><a href="https://rust-lang.github.io/async-book/">Async Book</a></li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>API Documentation</strong> - <a href="https://docs.rs/qbice">docs.rs/qbice</a></li>
<li><strong>GitHub</strong> - <a href="https://github.com/Simmypeet/qbice">github.com/Simmypeet/qbice</a></li>
<li><strong>Issues</strong> - Report bugs or request features on GitHub</li>
</ul>
<p>Let’s get started!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this tutorial, we’ll build a simple incremental calculator that can compute arithmetic expressions. This will teach you the fundamentals of QBICE: queries, executors, and the engine.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>First, create a new Rust project:</p>
<pre><code class="language-bash">cargo new qbice-calculator
cd qbice-calculator
</code></pre>
<p>Add QBICE to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
qbice = "0.2.0"
tokio = { version = "1", features = ["full"] }
tempfile = "3"
</code></pre>
<h2 id="what-well-build"><a class="header" href="#what-well-build">What We’ll Build</a></h2>
<p>Our calculator will support:</p>
<ul>
<li><strong>Variables</strong> - Named numeric values (A and B)</li>
<li><strong>Division</strong> - Dividing two values (with assertion that denominator != 0)</li>
<li><strong>Safe Division</strong> - Division that returns <code>None</code> for division by zero</li>
</ul>
<p>The key feature: when we change a variable’s value, only dependent computations will be recalculated. Plus, we’ll see how queries can depend on other queries (SafeDivide depends on Divide).</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Imagine we have these computations:</p>
<pre><code>fn Divide(Variable::A, Variable::B) -&gt; i32 {
    let a = read Variable::A;
    let b = read Variable::B;

    panic if b == 0;

    a / b
}

fn SafeDivide(Variable::A, Variable::B) -&gt; Option&lt;i32&gt; {
    let b = read Variable::B;

    if b == 0 {
        return None;
    }

    Some(
        Divide(Variable::A, Variable::B)
    )
}
</code></pre>
<p>If we start with <code>A = 42</code> and <code>B = 2</code>, and compute <code>SafeDivide(A, B)</code>, we get
<code>Some(21)</code>.</p>
<p>Now, if we change <code>B</code> to <code>0</code> and recompute <code>SafeDivide(A, B)</code>, we should get <code>None</code>.</p>
<p>Notice how <code>SafeDivide</code> depends on <code>Divide</code>, which in turn depends on <code>Variable::A</code> and <code>Variable::B</code>.</p>
<p>Finally, if we change <code>B</code> back to <code>2</code> and recompute, we should get <code>Some(21)</code> again
but without re-executing <code>Divide</code> since its result was cached.</p>
<p>QBICE automatically tracks these dependencies and handles the incremental updates.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>We’ll build this in stages:</p>
<ol>
<li><strong>Define Queries</strong> - Create types representing our computations</li>
<li><strong>Implement Executors</strong> - Write the logic for each computation</li>
<li><strong>Set Up the Engine</strong> - Configure QBICE to manage our queries</li>
<li><strong>Execute Queries</strong> - Run computations and see results</li>
<li><strong>Update Inputs</strong> - Change values and observe incremental updates</li>
</ol>
<p>Let’s start by defining our queries!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="defining-queries"><a class="header" href="#defining-queries">Defining Queries</a></h1>
<p>A <strong>query</strong> in QBICE represents a computation with an input (the query key) and an output (the query value). Let’s define the queries for our calculator.</p>
<h2 id="required-traits"><a class="header" href="#required-traits">Required Traits</a></h2>
<p>Every query type must implement several traits:</p>
<ul>
<li><code>Query</code> - The main trait defining the output type</li>
<li><code>StableHash</code> - For consistent hashing across runs</li>
<li><code>Identifiable</code> - For stable type identification</li>
<li><code>Encode</code> / <code>Decode</code> - For persistence</li>
<li><code>Debug</code>, <code>Clone</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Hash</code> - Standard Rust traits</li>
</ul>
<p>Fortunately, most of these can be derived automatically!</p>
<h2 id="variable-query"><a class="header" href="#variable-query">Variable Query</a></h2>
<p>First, let’s define a query for variables. Variables are inputs to our system—they don’t compute anything, they just hold values. We’ll use an enum for simplicity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::{
    Decode, Encode, Identifiable, Query, StableHash,
};

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub enum Variable {
    A,
    B,
}

impl Query for Variable {
    type Value = i32;
}
<span class="boring">}</span></code></pre>
<p>Let’s break this down:</p>
<h3 id="the-enum"><a class="header" href="#the-enum">The Enum</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Variable {
    A,
    B,
}
<span class="boring">}</span></code></pre>
<p>The enum itself is the query <strong>key</strong>. Different variants represent different queries. <code>Variable::A</code> and <code>Variable::B</code> are distinct queries. Using an enum is simpler than using strings for our example.</p>
<h3 id="the-derives"><a class="header" href="#the-derives">The Derives</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(
    Debug,              // For error messages
    Clone,              // Queries must be cloneable
    Copy,               // Cheap to copy (for enums)
    PartialEq, Eq,      // For comparing queries
    PartialOrd, Ord,    // For ordering (useful for sorted collections)
    Hash,               // For hash maps
    StableHash,         // For consistent hashing
    Identifiable,       // For type identification
    Encode, Decode,     // For persistence
)]
<span class="boring">}</span></code></pre>
<p>These derived traits enable QBICE to:</p>
<ul>
<li>Store queries in hash maps</li>
<li>Generate stable identifiers</li>
<li>Persist results to disk</li>
<li>Display debug information</li>
</ul>
<h3 id="the-query-trait"><a class="header" href="#the-query-trait">The Query Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Query for Variable {
    type Value = i32;
}
<span class="boring">}</span></code></pre>
<p>The <code>Value</code> associated type defines what this query produces. Variables produce <code>i32</code> values.</p>
<h2 id="divide-query"><a class="header" href="#divide-query">Divide Query</a></h2>
<p>Now let’s define a query that divides two variables:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub struct Divide {
    pub numerator: Variable,
    pub denominator: Variable,
}

impl Query for Divide {
    type Value = i32;
}
<span class="boring">}</span></code></pre>
<p>The <code>Divide</code> query takes two variables and produces their quotient. The key insight: <code>Divide</code> doesn’t actually perform the division—that’s the executor’s job. The query just describes <strong>what</strong> to compute.</p>
<p>Note: This version will panic if the denominator is zero (we’ll handle that with <code>SafeDivide</code>).</p>
<h2 id="safedivide-query"><a class="header" href="#safedivide-query">SafeDivide Query</a></h2>
<p>Now for the safe version that handles division by zero:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub struct SafeDivide {
    pub numerator: Variable,
    pub denominator: Variable,
}

impl Query for SafeDivide {
    type Value = Option&lt;i32&gt;;  // Returns None for division by zero!
}
<span class="boring">}</span></code></pre>
<p>Notice that <code>SafeDivide</code> returns <code>Option&lt;i32&gt;</code> instead of <code>i32</code>. This allows us to return <code>None</code> when dividing by zero, making our computation safe and preventing panics.</p>
<h2 id="why-separate-queries-from-execution"><a class="header" href="#why-separate-queries-from-execution">Why Separate Queries from Execution?</a></h2>
<p>You might wonder: why not just put the computation logic in the query itself?</p>
<p>The separation provides several benefits:</p>
<ol>
<li><strong>Decoupling</strong>: This might sound cliche, but separating the <em>what</em> (query)
from the <em>how</em> (executor) can sometime be beneficial. For example, in a large
scale query system if you want to do unit testing, you can mock out executors
without changing the query definitions.</li>
<li><strong>External Effects</strong>: Sometimes you can perform some side-effects in the executor
like logging, metrics, etc. NOTE: Be careful with side-effects in executors, some
side-effects that doesn’t influence the output value are usually okay, but anything that influences the output value will definitely break the semantics of incremental computation.</li>
</ol>
<h2 id="complete-code"><a class="header" href="#complete-code">Complete Code</a></h2>
<p>Here’s our complete query module:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::{
    Decode, Encode, Identifiable, Query, StableHash,
};

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub enum Variable {
    A,
    B,
}

impl Query for Variable {
    type Value = i32;
}

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub struct Divide {
    pub numerator: Variable,
    pub denominator: Variable,
}

impl Query for Divide {
    type Value = i32;
}

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    StableHash,
    Identifiable,
    Encode,
    Decode,
)]
pub struct SafeDivide {
    pub numerator: Variable,
    pub denominator: Variable,
}

impl Query for SafeDivide {
    type Value = Option&lt;i32&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li>Queries define <strong>what</strong> to compute, not <strong>how</strong></li>
<li>Query types are the <strong>keys</strong>; the associated <code>Value</code> type is the <strong>result</strong></li>
<li>Most required traits can be derived automatically</li>
<li>Each unique query instance (different field values) represents a distinct computation</li>
</ul>
<p>Next, we’ll implement the executors that actually perform these computations!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-executors"><a class="header" href="#implementing-executors">Implementing Executors</a></h1>
<p>Now that we’ve defined our queries, let’s implement the <strong>executors</strong> that actually perform the computations. Executors implement the <code>Executor</code> trait, which defines how to compute a value for a specific query type.</p>
<h2 id="the-executor-trait"><a class="header" href="#the-executor-trait">The Executor Trait</a></h2>
<p>The <code>Executor</code> trait has one required method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Executor&lt;Q: Query, C: Config&gt;: Send + Sync {
    async fn execute(
        &amp;self,
        query: &amp;Q,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Q::Value;
}
<span class="boring">}</span></code></pre>
<p>Let’s break this down:</p>
<ul>
<li><code>&amp;self</code> - The executor instance (you can store state here)</li>
<li><code>query: &amp;Q</code> - The specific query being executed</li>
<li><code>engine: &amp;TrackedEngine&lt;C&gt;</code> - Used to query other dependencies</li>
<li>Returns <code>Q::Value</code> - The computed result</li>
</ul>
<h2 id="divide-executor"><a class="header" href="#divide-executor">Divide Executor</a></h2>
<p>Let’s start with the <code>Divide</code> executor:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DivideExecutor;

impl&lt;C: Config&gt; Executor&lt;Divide, C&gt; for DivideExecutor {
    async fn execute(
        &amp;self,
        query: &amp;Divide,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; i32 {
        // Query the numerator
        let num = engine.query(&amp;query.numerator).await;

        // Query the denominator
        let denom = engine.query(&amp;query.denominator).await;

        // Assert denominator is not zero
        assert!(denom != 0, "denominator should not be zero");

        // Return the quotient
        num / denom
    }
}
<span class="boring">}</span></code></pre>
<p>This is where QBICE’s magic happens! Notice:</p>
<ol>
<li><strong>We query other queries</strong> - <code>engine.query()</code> executes dependencies</li>
<li><strong>Dependencies are tracked automatically</strong> - QBICE records that <code>Divide</code> depends on two <code>Variable</code> queries</li>
<li><strong>It’s async</strong> - We can await other queries without blocking</li>
<li><strong>We assert safety</strong> - This version panics if denominator is zero</li>
</ol>
<h2 id="safedivide-executor"><a class="header" href="#safedivide-executor">SafeDivide Executor</a></h2>
<p>Now for the safe version that handles division by zero:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SafeDivideExecutor;

impl&lt;C: Config&gt; Executor&lt;SafeDivide, C&gt; for SafeDivideExecutor {
    async fn execute(
        &amp;self,
        query: &amp;SafeDivide,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Option&lt;i32&gt; {
        // Query the denominator first
        let denom = engine.query(&amp;query.denominator).await;

        // Check for division by zero
        if denom == 0 {
            return None;
        }

        // Safe to divide - delegate to Divide query
        Some(
            engine.query(&amp;Divide {
                numerator: query.numerator,
                denominator: query.denominator,
            }).await
        )
    }
}
<span class="boring">}</span></code></pre>
<p>This executor demonstrates an important pattern:</p>
<ul>
<li><strong>Early return</strong> - We check for division by zero first</li>
<li><strong>Query composition</strong> - SafeDivide depends on Divide</li>
<li><strong>Error handling</strong> - Returns <code>None</code> instead of panicking</li>
</ul>
<h2 id="adding-state-to-executors"><a class="header" href="#adding-state-to-executors">Adding State to Executors</a></h2>
<p>Executors can maintain state. This is useful for tracking metrics,
like call counts. Maintaining state is ok as long as it doesn’t affect
the correctness of computations.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering};

pub struct DivideExecutor {
    call_count: AtomicUsize,
}

impl DivideExecutor {
    pub fn new() -&gt; Self {
        Self {
            call_count: AtomicUsize::new(0),
        }
    }

    pub fn call_count(&amp;self) -&gt; usize {
        self.call_count.load(Ordering::SeqCst)
    }
}

impl&lt;C: Config&gt; Executor&lt;Divide, C&gt; for DivideExecutor {
    async fn execute(
        &amp;self,
        query: &amp;Divide,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; i32 {
        // Increment counter
        self.call_count.fetch_add(1, Ordering::SeqCst);

        let num = engine.query(&amp;query.numerator).await;
        let denom = engine.query(&amp;query.denominator).await;

        assert!(denom != 0, "denominator should not be zero");

        num / denom
    }
}
<span class="boring">}</span></code></pre>
<p>Now we can verify that QBICE is actually performing incremental computation by checking how many times each executor was called!</p>
<h2 id="complete-code-1"><a class="header" href="#complete-code-1">Complete Code</a></h2>
<p>Here’s our complete executor module:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering};
use qbice::{Config, Executor, TrackedEngine};

// Import our query types
use crate::{Divide, SafeDivide};

pub struct DivideExecutor {
    pub call_count: AtomicUsize,
}

impl DivideExecutor {
    pub fn new() -&gt; Self {
        Self {
            call_count: AtomicUsize::new(0),
        }
    }
}

impl&lt;C: Config&gt; Executor&lt;Divide, C&gt; for DivideExecutor {
    async fn execute(
        &amp;self,
        query: &amp;Divide,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; i32 {
        self.call_count.fetch_add(1, Ordering::SeqCst);

        let num = engine.query(&amp;query.numerator).await;
        let denom = engine.query(&amp;query.denominator).await;

        assert!(denom != 0, "denominator should not be zero");

        num / denom
    }
}

pub struct SafeDivideExecutor {
    pub call_count: AtomicUsize,
}

impl SafeDivideExecutor {
    pub fn new() -&gt; Self {
        Self {
            call_count: AtomicUsize::new(0),
        }
    }
}

impl&lt;C: Config&gt; Executor&lt;SafeDivide, C&gt; for SafeDivideExecutor {
    async fn execute(
        &amp;self,
        query: &amp;SafeDivide,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Option&lt;i32&gt; {
        self.call_count.fetch_add(1, Ordering::SeqCst);

        let denom = engine.query(&amp;query.denominator).await;
        if denom == 0 {
            return None;
        }

        Some(
            engine.query(&amp;Divide {
                numerator: query.numerator,
                denominator: query.denominator,
            }).await
        )
    }
}
<span class="boring">}</span></code></pre>
<h2 id="key-takeaways-1"><a class="header" href="#key-takeaways-1">Key Takeaways</a></h2>
<ul>
<li>Executors define <strong>how</strong> to compute query results</li>
<li>Use <code>engine.query()</code> to depend on other queries</li>
<li>Dependencies are tracked automatically by QBICE</li>
<li>Executors can maintain state (like metrics) if it doesn’t affect correctness</li>
</ul>
<p>Next, we’ll set up the engine and register these executors!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="setting-up-the-engine"><a class="header" href="#setting-up-the-engine">Setting Up the Engine</a></h1>
<p>Now that we have queries and executors, let’s create and configure the QBICE engine. The engine is the central component that manages query execution, caching, and dependency tracking.</p>
<h2 id="creating-an-engine"><a class="header" href="#creating-an-engine">Creating an Engine</a></h2>
<p>The basic setup requires three components:</p>
<ol>
<li><strong>Plugin</strong> - For serialization/deserialization</li>
<li><strong>Database Factory</strong> - For persistent storage</li>
<li><strong>Hasher Builder</strong> - For stable hashing</li>
</ol>
<p>Here’s a simple setup:</p>
<pre class="playground"><code class="language-rust">use std::sync::Arc;
use qbice::{
    Engine, DefaultConfig,
    serialize::Plugin,
    stable_hash::{SeededStableHasherBuilder, Sip128Hasher},
    storage::kv_database::rocksdb::RocksDB,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a temporary directory for the database
    let temp_dir = tempfile::tempdir()?;

    // Create the engine
    let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
        Plugin::default(),
        RocksDB::factory(temp_dir.path()),
        SeededStableHasherBuilder::&lt;Sip128Hasher&gt;::new(0),
    )?;

    // Engine is ready to use!
    Ok(())
}</code></pre>
<p>Let’s examine each component:</p>
<h2 id="plugin---serialization"><a class="header" href="#plugin---serialization">Plugin - Serialization</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Plugin::default()
<span class="boring">}</span></code></pre>
<p>The plugin handles serialization and deserialization of query keys and values.
For custom serialization needs, you can create your own plugin.</p>
<h2 id="database-factory---persistence"><a class="header" href="#database-factory---persistence">Database Factory - Persistence</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RocksDB::factory(temp_dir.path())
<span class="boring">}</span></code></pre>
<p>QBICE supports pluggable storage backends. RocksDB is the default and recommended choice for production use. The factory creates a database instance at the specified path.</p>
<p>Available backends:</p>
<ul>
<li><strong>RocksDB</strong> (default) - Production-ready, embedded database</li>
<li><strong>fjall</strong> - Alternative key-value store</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using RocksDB (requires "rocksdb" feature)
use qbice::storage::kv_database::rocksdb::RocksDB;
let factory = RocksDB::factory("/path/to/db");

// Using fjall (requires "fjall" feature)
use qbice::storage::kv_database::fjall::Fjall;
let factory = Fjall::factory("/path/to/db");
<span class="boring">}</span></code></pre>
<h2 id="hasher-builder---stable-hashing"><a class="header" href="#hasher-builder---stable-hashing">Hasher Builder - Stable Hashing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SeededStableHasherBuilder::&lt;Sip128Hasher&gt;::new(0)
<span class="boring">}</span></code></pre>
<p>The hasher generates stable 128-bit hashes for queries. The seed (0 in this example) should be consistent across runs for the same project.</p>
<p><strong>Important</strong>: Use the same seed when reloading a database, or cached results won’t match!</p>
<h2 id="registering-executors"><a class="header" href="#registering-executors">Registering Executors</a></h2>
<p>After creating the engine, register all your executors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

// Create executor instances
let divide_executor = Arc::new(DivideExecutor::new());
let safe_divide_executor = Arc::new(SafeDivideExecutor::new());

// Register with the engine
engine.register_executor(divide_executor.clone());
engine.register_executor(safe_divide_executor.clone());
<span class="boring">}</span></code></pre>
<p>A few important notes:</p>
<ul>
<li>Executors must be wrapped in <code>Arc</code> for shared ownership</li>
<li>Each query type needs exactly one executor</li>
<li>Registering the same query type twice will overwrite the first executor</li>
<li>You can keep <code>Arc</code> clones to access executor state (like call counters)</li>
<li>There’s no executor for <code>Variable</code> since it’s an input query</li>
<li>It’s expected to register the same executors again after reloading an engine
from disk</li>
</ul>
<h2 id="creating-a-trackedengine"><a class="header" href="#creating-a-trackedengine">Creating a TrackedEngine</a></h2>
<p>To actually execute queries and set inputs, first convert the engine to an <code>Arc</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Move engine into Arc for shared ownership
let engine = Arc::new(engine);
<span class="boring">}</span></code></pre>
<p>The <code>Arc</code> (Atomic Reference Count) enables shared ownership of the engine, which is required for both input sessions and query execution.</p>
<h2 id="setting-input-values"><a class="header" href="#setting-input-values">Setting Input Values</a></h2>
<p>Before querying, set the initial values for input queries:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an input session (requires &amp;Arc&lt;Engine&gt;)
{
    let mut input_session = engine.input_session();

    // Set variable values
    input_session.set_input(Variable::A, 42);
    input_session.set_input(Variable::B, 2);

} // Session is committed when dropped
<span class="boring">}</span></code></pre>
<p>The input session is a transaction-like mechanism:</p>
<ul>
<li>Changes are batched</li>
<li>Dirty propagation happens when the session is dropped</li>
<li>You can set many inputs efficiently</li>
</ul>
<h2 id="executing-queries"><a class="header" href="#executing-queries">Executing Queries</a></h2>
<p>Create a <code>TrackedEngine</code> to execute queries:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a tracked engine for querying
let tracked = engine.tracked();

// Now you can execute queries!
let result = tracked.query(&amp;SafeDivide {
    numerator: Variable::A,
    denominator: Variable::B,
}).await;

assert_eq!(result, Some(21));
<span class="boring">}</span></code></pre>
<p>The <code>TrackedEngine</code> is a lightweight wrapper that:</p>
<ul>
<li>Tracks dependencies during query execution</li>
<li>Provides the <code>query()</code> method</li>
<li>Can be cloned cheaply</li>
</ul>
<p>Each TrackedEngine is tied to a specific timestamp of the engine’s state when
it’s created.</p>
<p>Every time you update inputs, the engine’s timestamp advances leaving the old
TrackedEngine stale.</p>
<p>Calling stale tracked engines will return a future that
never resolves, forcing you to drop the future.</p>
<h2 id="complete-setup-example"><a class="header" href="#complete-setup-example">Complete Setup Example</a></h2>
<p>Here’s everything together:</p>
<pre class="playground"><code class="language-rust">use std::sync::Arc;
use qbice::{
    Engine, DefaultConfig,
    serialize::Plugin,
    stable_hash::{SeededStableHasherBuilder, Sip128Hasher},
    storage::kv_database::rocksdb::RocksDB,
};

// Import our types
use crate::{
    Variable, Divide, SafeDivide,
    VariableExecutor, DivideExecutor, SafeDivideExecutor,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Create the engine
    let temp_dir = tempfile::tempdir()?;
    let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
        Plugin::default(),
        RocksDB::factory(temp_dir.path()),
        SeededStableHasherBuilder::&lt;Sip128Hasher&gt;::new(0),
    )?;

    // 2. Register executors
    let divide_executor = Arc::new(DivideExecutor::new());
    let safe_divide_executor = Arc::new(SafeDivideExecutor::new());

    engine.register_executor(divide_executor.clone());
    engine.register_executor(safe_divide_executor.clone());

    // 3. Wrap in Arc for shared ownership
    let engine = Arc::new(engine);

    // 4. Set input values
    {
        let mut input_session = engine.input_session();
        input_session.set_input(Variable::A, 42);
        input_session.set_input(Variable::B, 2);
    }

    // 5. Create tracked engine for querying
    let tracked = engine.tracked();

    // 6. Ready to execute queries!
    println!("Setup complete!");

    Ok(())
}</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<p>QBICE supports custom configurations via the <code>Config</code> trait. We have provided
a sensible default configuration called <code>DefaultConfig</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::DefaultConfig;
let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(...)?;
<span class="boring">}</span></code></pre>
<p>For advanced use cases, you can implement your own <code>Config</code> type to customize behavior.</p>
<h2 id="lifetime-management"><a class="header" href="#lifetime-management">Lifetime Management</a></h2>
<p>Key points about engine lifetime:</p>
<ul>
<li><strong>Engine</strong> - Owns the database and executor registry</li>
<li><strong>Arc&lt;Engine&gt;</strong> - Shared ownership, can be cloned and passed around</li>
<li><strong>TrackedEngine</strong> - Lightweight wrapper, cheap to clone</li>
<li><strong>New TrackedEngine</strong> - Create a new one after updating inputs</li>
</ul>
<p>Typical pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The engine is wrapped in Arc, so no mutable access is needed
{
    let tracked = engine.tracked();
    // Use tracked for queries...
} // Drop tracked

// Create a new input session to update inputs
{
    let mut input_session = engine.input_session();
    // Update inputs...
}
<span class="boring">}</span></code></pre>
<h2 id="key-takeaways-2"><a class="header" href="#key-takeaways-2">Key Takeaways</a></h2>
<ul>
<li>The engine requires a plugin, database factory, and hasher builder</li>
<li>Register executors with <code>register_executor()</code></li>
<li>Set input values via <code>input_session()</code></li>
<li>Convert to <code>Arc&lt;Engine&gt;</code> and call <code>tracked()</code> to execute queries</li>
<li><code>TrackedEngine</code> has an associated timestamp; create a new one after input
updates</li>
</ul>
<p>Next, we’ll execute some queries and see incremental computation in action!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="executing-queries-1"><a class="header" href="#executing-queries-1">Executing Queries</a></h1>
<p>Now that we’ve set up the engine, let’s execute some queries and see QBICE’s incremental computation in action!</p>
<h2 id="basic-query-execution"><a class="header" href="#basic-query-execution">Basic Query Execution</a></h2>
<p>Executing a query is straightforward—call <code>query()</code> on a <code>TrackedEngine</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tracked = engine.tracked();

let result = tracked.query(&amp;SafeDivide {
    numerator: Variable::A,
    denominator: Variable::B,
}).await;

println!("SafeDivide(A, B) = {:?}", result); // Output: SafeDivide(A, B) = Some(21)
<span class="boring">}</span></code></pre>
<p>Remember, we set <code>Variable::A = 42</code> and <code>Variable::B = 2</code> in our input session, so <code>42 / 2 = 21</code>.</p>
<h2 id="verifying-incremental-computation"><a class="header" href="#verifying-incremental-computation">Verifying Incremental Computation</a></h2>
<p>Let’s prove QBICE is actually caching results. Remember we added call counters to our executors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Execute some queries
let tracked = engine.tracked();

tracked.query(&amp;Divide {
    numerator: Variable::A,
    denominator: Variable::B,
}).await;

tracked.query(&amp;SafeDivide {
    numerator: Variable::A,
    denominator: Variable::B,
}).await;

// Check call counts
println!("Divide called: {} times", divide_executor.call_count.load(Ordering::SeqCst));
println!("SafeDivide called: {} times", safe_divide_executor.call_count.load(Ordering::SeqCst));
<span class="boring">}</span></code></pre>
<p>Expected output:</p>
<pre><code>Divide called: 1 times
SafeDivide called: 1 times
</code></pre>
<p>The counts didn’t increase! QBICE returned cached results because nothing changed.</p>
<h2 id="querying-with-different-keys"><a class="header" href="#querying-with-different-keys">Querying with Different Keys</a></h2>
<p>Each unique query key is tracked separately:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tracked = engine.tracked();

// These are different queries (different keys)
let ab = tracked.query(&amp;Divide {
    numerator: Variable::A,
    denominator: Variable::B,
}).await;

let aa = tracked.query(&amp;Divide {
    numerator: Variable::A,
    denominator: Variable::A,
}).await;

println!("Divide(A, B) = {}", ab); // 21
println!("Divide(A, A) = {}", aa); // 1

// Both queries were executed (check the call count)
println!("Divide called: {} times", divide_executor.call_count.load(Ordering::SeqCst));
<span class="boring">}</span></code></pre>
<p>Expected output:</p>
<pre><code>Divide called: 2 times
</code></pre>
<p>QBICE distinguishes between <code>Divide { numerator: A, denominator: A }</code> and <code>Divide { numerator: A, denominator: B }</code> because they have different keys.</p>
<h2 id="async-concurrent-execution"><a class="header" href="#async-concurrent-execution">Async Concurrent Execution</a></h2>
<p>Since queries are async, you can execute multiple independent queries concurrently:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::join;

let tracked = engine.tracked();

// Execute multiple queries in parallel
let (result1, result2) = join!(
    tracked.query(&amp;Divide { numerator: Variable::A, denominator: Variable::B }),
    tracked.query(&amp;SafeDivide { numerator: Variable::A, denominator: Variable::B }),
);

println!("Divide(A, B) = {}", result1);     // 21
println!("SafeDivide(A, B) = {:?}", result2); // Some(21)
<span class="boring">}</span></code></pre>
<p>QBICE can safely execute these in parallel, handling any shared dependencies automatically.</p>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here’s a complete example putting it all together:</p>
<pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::Ordering;
use qbice::{
    Engine, DefaultConfig,
    serialize::Plugin,
    stable_hash::{SeededStableHasherBuilder, Sip128Hasher},
    storage::kv_database::rocksdb::RocksDB,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let temp_dir = tempfile::tempdir()?;
    let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
        Plugin::default(),
        RocksDB::factory(temp_dir.path()),
        SeededStableHasherBuilder::&lt;Sip128Hasher&gt;::new(0),
    )?;

    let divide_executor = Arc::new(DivideExecutor::new());
    let safe_divide_executor = Arc::new(SafeDivideExecutor::new());

    engine.register_executor(Arc::new(VariableExecutor));
    engine.register_executor(divide_executor.clone());
    engine.register_executor(safe_divide_executor.clone());

    // Wrap engine in Arc
    let engine = Arc::new(engine);

    // Set initial values
    {
        let mut input_session = engine.input_session();
        input_session.set_input(Variable::A, 42);
        input_session.set_input(Variable::B, 2);
    }

    let tracked = engine.tracked();

    // Execute queries
    println!("=== First Execution ===");
    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;
    println!("SafeDivide(A, B) = {:?}", result);
    println!("Divide called: {} times", divide_executor.call_count.load(Ordering::SeqCst));
    println!("SafeDivide called: {} times", safe_divide_executor.call_count.load(Ordering::SeqCst));

    // Execute again (should use cache)
    println!("\n=== Second Execution (cached) ===");
    let result2 = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;
    println!("SafeDivide(A, B) = {:?}", result2);
    println!("Divide called: {} times", divide_executor.call_count.load(Ordering::SeqCst));
    println!("SafeDivide called: {} times", safe_divide_executor.call_count.load(Ordering::SeqCst));

    Ok(())
}</code></pre>
<p>Expected output:</p>
<pre><code>=== First Execution ===
SafeDivide(A, B) = Some(21)
Divide called: 1 times
SafeDivide called: 1 times

=== Second Execution (cached) ===
SafeDivide(A, B) = Some(21)
Divide called: 1 times
SafeDivide called: 1 times
</code></pre>
<h2 id="key-takeaways-3"><a class="header" href="#key-takeaways-3">Key Takeaways</a></h2>
<ul>
<li>Use <code>tracked.query(&amp;query_key)</code> to execute queries</li>
<li>Results are automatically cached</li>
<li>Same query keys return cached results without re-execution</li>
<li>Different query keys are tracked separately</li>
<li>Async execution allows for concurrent query processing</li>
<li>Dependencies are tracked automatically</li>
</ul>
<p>Next, we’ll learn how to update inputs and observe incremental recomputation!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="updating-inputs"><a class="header" href="#updating-inputs">Updating Inputs</a></h1>
<p>The real power of incremental computation shines when inputs change. QBICE automatically determines what needs to be recomputed and what can remain cached. Let’s see how this works!</p>
<h2 id="updating-input-values"><a class="header" href="#updating-input-values">Updating Input Values</a></h2>
<p>To update inputs, create a new input session. Note that the engine must be wrapped in <code>Arc</code> to call <code>input_session()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First execution
{
    let tracked = engine.tracked();
    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;
    println!("SafeDivide(A, B) = {:?}", result); // Some(21)
} // Drop tracked

// Update input (engine is already in Arc)
{
    let mut input_session = engine.input_session();
    input_session.set_input(Variable::A, 84); // Changed from 42 to 84
} // Changes committed when dropped

// Query again
{
    let tracked = engine.tracked();
    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;
    println!("SafeDivide(A, B) = {:?}", result); // Some(42)
}
<span class="boring">}</span></code></pre>
<h2 id="observing-incremental-recomputation"><a class="header" href="#observing-incremental-recomputation">Observing Incremental Recomputation</a></h2>
<p>Let’s verify QBICE’s incremental computation with an interesting example that
tracks executor call counts.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::Ordering;

// Reset call counters
divide_executor.call_count.store(0, Ordering::SeqCst);
safe_divide_executor.call_count.store(0, Ordering::SeqCst);

// Wrap engine in Arc (required for input_session)
let engine = Arc::new(engine);

// Set up initial state: A=42, B=2
{
    let mut input_session = engine.input_session();
    input_session.set_input(Variable::A, 42);
    input_session.set_input(Variable::B, 2);
}

// Execute SafeDivide query
{
    let tracked = engine.tracked();

    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;

    println!("SafeDivide(A, B) = {:?}", result); // Some(21)
}

println!("Initial execution (A=42, B=2):");
println!("  Divide called: {}", divide_executor.call_count.load(Ordering::SeqCst));
println!("  SafeDivide called: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));
// Output: Divide: 1, SafeDivide: 1
<span class="boring">}</span></code></pre>
<p>Now let’s change B to 0 to trigger division by zero:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change B to 0 (engine is already in Arc)
{
    let mut input_session = engine.input_session();
    input_session.set_input(Variable::B, 0);
}

// Query again
{
    let tracked = engine.tracked();

    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;

    println!("SafeDivide(A, B) = {:?}", result); // None
}

println!("After changing B to 0:");
println!("  Divide called: {}", divide_executor.call_count.load(Ordering::SeqCst));
println!("  SafeDivide called: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));
// Output: Divide: 1, SafeDivide: 2
<span class="boring">}</span></code></pre>
<p>Notice that:</p>
<ul>
<li><code>SafeDivide</code> was executed again (count increased from 1 to 2)</li>
<li><code>Divide</code> was <strong>NOT</strong> executed (count stayed at 1)</li>
<li>This is because <code>SafeDivide</code> returns early when denominator is 0</li>
</ul>
<p>Now let’s change B back to 2:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change B back to 2
{
    let mut input_session = engine.input_session();
    input_session.set_input(Variable::B, 2);
}

// Query again
{
    let tracked = engine.tracked();

    let result = tracked.query(&amp;SafeDivide {
        numerator: Variable::A,
        denominator: Variable::B,
    }).await;

    println!("SafeDivide(A, B) = {:?}", result); // Some(21)
}

println!("After changing B back to 2:");
println!("  Divide called: {}", divide_executor.call_count.load(Ordering::SeqCst));
println!("  SafeDivide called: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));
// Output: Divide: 1, SafeDivide: 3
<span class="boring">}</span></code></pre>
<p>This demonstrates QBICE’s incremental recomputation:</p>
<ul>
<li><code>SafeDivide</code> executed again (count: 2 → 3)</li>
<li><code>Divide</code> <strong>still didn’t execute</strong> (count stayed at 1)</li>
<li>Even though B changed, its value is back to 2, same as the original</li>
<li><code>Divide</code>’s cached result from the first execution is still valid!</li>
<li>QBICE detects this via fingerprint comparison and reuses the cached value</li>
</ul>
<h2 id="understanding-dirty-propagation"><a class="header" href="#understanding-dirty-propagation">Understanding Dirty Propagation</a></h2>
<p>When you change an input, QBICE performs <strong>dirty propagation</strong>:</p>
<ol>
<li>The changed input is marked dirty</li>
<li>All queries that depend on it are marked dirty (transitively)</li>
<li>When a dirty query is requested, it checks its dependencies</li>
<li>If a dependency’s value hasn’t actually changed (via fingerprint comparison), recomputation may stop</li>
</ol>
<p>In our example above, when we changed B from 0 back to 2:</p>
<ul>
<li>B was marked dirty</li>
<li><code>Divide(A, B)</code> was marked dirty (depends on B)</li>
<li><code>SafeDivide(A, B)</code> was marked dirty (depends on Divide)</li>
<li>When <code>SafeDivide</code> executed, it sees that <code>Divide</code> is dirty</li>
<li><code>Divides</code> checks its dependencies with what they were before:
<ul>
<li><code>Variable::A</code> is unchanged (42)</li>
<li><code>Variable::B</code> is unchanged (2)</li>
</ul>
</li>
<li>Since both inputs are the same as before, <code>Divide</code> reuses its cached result</li>
<li>Thus, <code>Divide</code>’s call count remains at 1 throughout</li>
</ul>
<h2 id="batched-updates"><a class="header" href="#batched-updates">Batched Updates</a></h2>
<p>You can update multiple inputs at once:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut input_session = engine.input_session();
    input_session.set_input(Variable::A, 100);
    input_session.set_input(Variable::B, 5);
} // All changes committed atomically
<span class="boring">}</span></code></pre>
<h2 id="complete-incremental-example"><a class="header" href="#complete-incremental-example">Complete Incremental Example</a></h2>
<p>Here’s a complete example demonstrating incremental computation:</p>
<pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::Ordering;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let temp_dir = tempfile::tempdir()?;
    let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
        Plugin::default(),
        RocksDB::factory(temp_dir.path()),
        SeededStableHasherBuilder::&lt;Sip128Hasher&gt;::new(0),
    )?;

    let divide_executor = Arc::new(DivideExecutor::new());
    let safe_divide_executor = Arc::new(SafeDivideExecutor::new());

    engine.register_executor(Arc::new(VariableExecutor));
    engine.register_executor(divide_executor.clone());
    engine.register_executor(safe_divide_executor.clone());

    // Wrap engine in Arc
    let engine = Arc::new(engine);

    // Initial setup
    {
        let mut input_session = engine.input_session();
        input_session.set_input(Variable::A, 42);
        input_session.set_input(Variable::B, 2);
    }

    // Computation 1: Initial A=42, B=2
    println!("=== Initial Computation (A=42, B=2) ===");
    {
        let tracked = engine.tracked();
        let result = tracked.query(&amp;SafeDivide {
            numerator: Variable::A,
            denominator: Variable::B,
        }).await;
        println!("SafeDivide(A, B) = {:?}", result);
    }
    println!("Divide executions: {}", divide_executor.call_count.load(Ordering::SeqCst));
    println!("SafeDivide executions: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));

    // Update B to 0 (division by zero!)
    println!("\n=== Update B to 0 ===");
    {
        let mut input_session = engine.input_session();
        input_session.set_input(Variable::B, 0);
    }

    // Computation 2: SafeDivide returns None
    {
        let tracked = engine.tracked();
        let result = tracked.query(&amp;SafeDivide {
            numerator: Variable::A,
            denominator: Variable::B,
        }).await;
        println!("SafeDivide(A, B) = {:?}", result);
    }
    println!("Divide executions: {}", divide_executor.call_count.load(Ordering::SeqCst));
    println!("SafeDivide executions: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));

    // Update B back to 2 (original value!)
    println!("\n=== Update B back to 2 ===");
    {
        let mut input_session = engine.input_session();
        input_session.set_input(Variable::B, 2);
    }

    // Computation 3: SafeDivide returns Some(21) again
    {
        let tracked = engine.tracked();
        let result = tracked.query(&amp;SafeDivide {
            numerator: Variable::A,
            denominator: Variable::B,
        }).await;
        println!("SafeDivide(A, B) = {:?}", result);
    }
    println!("Divide executions: {}", divide_executor.call_count.load(Ordering::SeqCst));
    println!("SafeDivide executions: {}", safe_divide_executor.call_count.load(Ordering::SeqCst));

    Ok(())
}</code></pre>
<p>Expected output:</p>
<pre><code>=== Initial Computation (A=42, B=2) ===
SafeDivide(A, B) = Some(21)
Divide executions: 1
SafeDivide executions: 1

=== Update B to 0 ===
SafeDivide(A, B) = None
Divide executions: 1
SafeDivide executions: 2

=== Update B back to 2 ===
SafeDivide(A, B) = Some(21)
Divide executions: 1
SafeDivide executions: 3
</code></pre>
<h2 id="graph-illustration"><a class="header" href="#graph-illustration">Graph Illustration</a></h2>
<p>To illustrate, this is how compoutation graph looks like on the first run:</p>
<pre><code class="language-txt">                  Some(21)
                     |
               SafeDivide(A, B)---------+
                     |                  |
                     21                 2
                     |                  |
           +-----Divide(A, B)------+    |
           |                       |    |
           42                      2    |
           |                       |    |
        Variable::A             Variable::B
           |                         |
           42                        2
</code></pre>
<p>Note that each edge represents a dependency and it records the value that it saw
at that time.</p>
<p>Next, when we change B to 0:</p>
<pre><code class="language-txt">                  Some(21)
                     |
               SafeDivide(A, B)---------+
                     |                  |
                     21*                2*
                     |                  |
           +-----Divide(A, B)------+    |
           |                       |    |
           42                      2*   |
           |                       |    |
        Variable::A             Variable::B
           |                         |
           42                        0
</code></pre>
<p>Here we mark the dirtied edges with a <code>*</code>. When we changed B to 0, all
transitive edges were marked dirty.</p>
<p>Here when we query for <code>SafeDivide(A, B)</code>, it sees that its dependency
<code>Divide(A, B)</code> and <code>Variable::B</code> are dirty, so it recomputes.</p>
<pre><code class="language-txt">                   None
                     |
               SafeDivide(A, B)---------+
                                        |
                                        0
                                        |
           +-----Divide(A, B)------+    |
           |                       |    |
           42                      2*   |
           |                       |    |
        Variable::A             Variable::B
           |                         |
           42                        0
</code></pre>
<p>Here, <code>SafeDivide</code> returns early because denominator is 0, so <code>Divide</code> is never executed. Note that the edge from <code>Divide(A, B)</code> to <code>Variable::B</code> remains dirty.</p>
<p>Finally, when we change B back to 2:</p>
<pre><code class="language-txt">                  Some(21)
                     |
               SafeDivide(A, B)---------+
                                        |
                                        2*
                                        |
           +-----Divide(A, B)------+    |
           |                       |    |
           42                      2*   |
           |                       |    |
        Variable::A             Variable::B
           |                         |
           42                        2
</code></pre>
<p>When <code>SafeDivide</code> executes, it sees that <code>Variable::B</code> is dirty, so it
recomputes, which means <code>Divide</code> is also invoked.</p>
<p>However, according to above graph, the last time <code>Divide</code> executed, both its
inputs (<code>Variable::A</code> and <code>Variable::B</code>) had the same values (42 and 2
respectively). Since nothing has changed, <code>Divide</code> reuses its cached result and
does not execute again.</p>
<p>Resulting in the final graph:</p>
<pre><code class="language-txt">                  Some(21)
                     |
               SafeDivide(A, B)---------+
                     |                  |
                     21*                2*
                     |                  |
           +-----Divide(A, B)------+    |
           |                       |    |
           42                      2*   |
           |                       |    |
        Variable::A             Variable::B
           |                         |
           42                        2
</code></pre>
<h2 id="key-takeaways-4"><a class="header" href="#key-takeaways-4">Key Takeaways</a></h2>
<ul>
<li>Drop the old <code>TrackedEngine</code> and create a new one after updating inputs</li>
<li>Create a new input session to update values</li>
<li>QBICE automatically tracks which queries are affected</li>
<li>Only queries that depend on changed inputs are recomputed</li>
<li>Fingerprint-based comparison prevents unnecessary recomputation</li>
<li>Multiple inputs can be updated in a single session</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h2>
<p>You’ve completed the tutorial! You now know how to:</p>
<ul>
<li>Define queries and implement executors</li>
<li>Set up the engine and register components</li>
<li>Execute queries and build dependency graphs</li>
<li>Update inputs and leverage incremental computation</li>
</ul>
<p>For deeper understanding, continue to the <strong>Reference</strong> section to learn about each component in detail, or explore <strong>Advanced Topics</strong> for optimization techniques like firewall and projection queries.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="firewall-and-projection-queries"><a class="header" href="#firewall-and-projection-queries">Firewall and Projection Queries</a></h1>
<p><strong>Firewall queries</strong> and <strong>projection queries</strong> are advanced optimization techniques that work together to provide fine-grained change detection and prevent unnecessary dirty propagation in dense dependency graphs. They’re particularly useful for expensive global analysis queries that have many dependents.</p>
<h2 id="the-problem-chokepoints"><a class="header" href="#the-problem-chokepoints">The Problem: Chokepoints</a></h2>
<p>Consider a compiler that performs global type analysis. This analysis:</p>
<ul>
<li>Depends on many input files</li>
<li>Produces a large type table</li>
<li>Is depended upon by hundreds of downstream queries</li>
</ul>
<p>When any input file changes:</p>
<ol>
<li>The global analysis is marked dirty</li>
<li><strong>All</strong> downstream queries are marked dirty (transitively)</li>
<li>On next execution, hundreds of queries need verification</li>
</ol>
<p>This creates a <strong>chokepoint</strong> where a single change causes excessive dirty propagation.</p>
<h2 id="the-solution-firewalls"><a class="header" href="#the-solution-firewalls">The Solution: Firewalls</a></h2>
<p>A firewall query acts as a boundary that limits dirty propagation:</p>
<pre><code>Input Changes
    ↓
Firewall Query (checked first)
    ↓ (only if result changed)
Downstream Queries
</code></pre>
<p>When an input changes:</p>
<ol>
<li>Dirty propagation stops at the firewall</li>
<li>When the firewall is requested, it’s recomputed</li>
<li><strong>Only if the firewall’s output changes</strong> does dirty propagation continue</li>
</ol>
<h2 id="defining-a-firewall-query"><a class="header" href="#defining-a-firewall-query">Defining a Firewall Query</a></h2>
<p>Mark a query as a firewall by overriding <code>execution_style()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::{Query, ExecutionStyle};

#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GlobalTypeAnalysis {
    // Input parameters
}

impl Query for GlobalTypeAnalysis {
    type Value = TypeTable;  // Large result

    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Firewall
    }
}
<span class="boring">}</span></code></pre>
<h2 id="how-firewalls-work"><a class="header" href="#how-firewalls-work">How Firewalls Work</a></h2>
<h3 id="without-firewall"><a class="header" href="#without-firewall">Without Firewall</a></h3>
<pre><code>Input → Analysis → [100 downstream queries all marked dirty]
</code></pre>
<p>When input changes:</p>
<ul>
<li>Analysis marked dirty</li>
<li>100 queries marked dirty</li>
<li>On next query, must verify all 100 queries</li>
</ul>
<h3 id="with-firewall"><a class="header" href="#with-firewall">With Firewall</a></h3>
<pre><code>Input → Analysis [FIREWALL] → [100 downstream queries]
</code></pre>
<p>When input changes:</p>
<ul>
<li>Analysis marked dirty</li>
<li>Downstream queries <strong>NOT</strong> marked dirty</li>
<li>On next query:
<ol>
<li>Analysis is recomputed</li>
<li>If result unchanged, return cached value</li>
<li>Downstream queries remain clean!</li>
</ol>
</li>
</ul>
<h2 id="example-global-analysis"><a class="header" href="#example-global-analysis">Example: Global Analysis</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

#[derive(Debug, Clone, StableHash)]
pub struct TypeTable {
    pub types: HashMap&lt;ID, Type&gt;,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GlobalTypeAnalysis;

impl Query for GlobalTypeAnalysis {
    type Value = Arc&lt;TypeTable&gt;;

    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Firewall
    }
}

pub struct GlobalTypeAnalysisExecutor;

impl&lt;C: Config&gt; Executor&lt;GlobalTypeAnalysis, C&gt; for GlobalTypeAnalysisExecutor {
    async fn execute(
        &amp;self,
        _query: &amp;GlobalTypeAnalysis,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; TypeTable {
        // This is expensive and depends on many inputs
        let files = engine.query(&amp;GetAllSourceFiles).await;

        let mut types = HashMap::new();
        for file in files {
            let file_types = engine.query(&amp;ParseFile {
                path: file.path.clone(),
            }).await;
            types.extend(file_types);
        }

        TypeTable { types }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="downstream-query"><a class="header" href="#downstream-query">Downstream Query</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetFunctionType {
    pub function_name: ID,
}

impl Query for GetFunctionType {
    type Value = Option&lt;Type&gt;;
}

impl&lt;C: Config&gt; Executor&lt;GetFunctionType, C&gt; for GetFunctionTypeExecutor {
    async fn execute(
        &amp;self,
        query: &amp;GetFunctionType,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Option&lt;Type&gt; {
        // Depends on the firewall
        let table = engine.query(&amp;GlobalTypeAnalysis).await;
        table.types.get(&amp;query.function_name).cloned()
    }
}
<span class="boring">}</span></code></pre>
<h2 id="transitive-firewall-edges"><a class="header" href="#transitive-firewall-edges">Transitive Firewall Edges</a></h2>
<p>Queries that transitively depend on a firewall maintain special <strong>transitive firewall edges</strong>:</p>
<pre><code>Firewall
    ↓
  Query A
    ↓
  Query B  ← has transitive edge to Firewall
</code></pre>
<p>When Query B is requested:</p>
<ol>
<li>It first checks the Firewall directly</li>
<li>If Firewall changed, dirty flags propagate from Firewall → A → B</li>
<li>Then normal verification continues</li>
</ol>
<p>This ensures correctness while limiting dirty propagation.</p>
<h2 id="when-to-use-firewalls"><a class="header" href="#when-to-use-firewalls">When to Use Firewalls</a></h2>
<p>Firewall is best when there are many dependents on the firewall query, making
dirty propagation traversing large portions of the graph costly.</p>
<h2 id="when-not-to-use-firewalls"><a class="header" href="#when-not-to-use-firewalls">When NOT to Use Firewalls</a></h2>
<p>Avoid firewalls when:</p>
<ol>
<li><strong>Too much firewalls</strong> - Extra memory overhead for maintaining firewall edges</li>
<li><strong>Few dependents</strong> - No chokepoint exists</li>
</ol>
<h2 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h2>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ul>
<li><strong>Reduced dirty propagation</strong> - Potentially thousands of queries stay clean</li>
<li><strong>Fewer verifications</strong> - Less work during repairation</li>
</ul>
<h3 id="costs"><a class="header" href="#costs">Costs</a></h3>
<ul>
<li><strong>Increased complexity</strong> - More complex dependency tracking</li>
<li><strong>Memory overhead</strong> - Transitive firewall edges stored</li>
</ul>
<h1 id="projection-queries"><a class="header" href="#projection-queries">Projection Queries</a></h1>
<p><strong>Projection queries</strong> work together with firewall queries to provide fine-grained change detection. They solve the over-invalidation problem by reading specific slices of large firewall results.</p>
<h2 id="the-problem-over-invalidation"><a class="header" href="#the-problem-over-invalidation">The Problem: Over-Invalidation</a></h2>
<p>Consider a firewall query that produces a large result:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Query for GlobalTypeTable {
    type Value = Arc&lt;HashMap&lt;ID, Type&gt;&gt;;  // 1000+ entries
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Firewall
    }
}
<span class="boring">}</span></code></pre>
<p>Downstream queries typically read just one entry:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C: Config&gt; Executor&lt;GetFunctionType, C&gt; for GetFunctionTypeExecutor {
    async fn execute(&amp;self, query: &amp;GetFunctionType, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Option&lt;Type&gt; {
        let table = engine.query(&amp;GlobalTypeTable).await;
        table.get(&amp;query.function_name).cloned()  // Only reads ONE entry!
    }
}
<span class="boring">}</span></code></pre>
<p>The problem:</p>
<ul>
<li>A change affects one entry in the table</li>
<li>The firewall result “changed” (different hash)</li>
<li><strong>All</strong> downstream queries are marked dirty</li>
<li>In reality, only small subset of downstream queries are actually affected</li>
</ul>
<h2 id="the-solution-projections"><a class="header" href="#the-solution-projections">The Solution: Projections</a></h2>
<p>Projection queries extract specific data from firewall/projection results:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetFunctionType {
    pub function_name: ID,
}

impl Query for GetFunctionType {
    type Value = Option&lt;Type&gt;;

    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection  // Mark as projection!
    }
}
<span class="boring">}</span></code></pre>
<p>Key properties:</p>
<ul>
<li><strong>Must only depend on Firewall</strong></li>
<li><strong>Should be very fast</strong> (memory access, hash lookup, field access)</li>
<li><strong>Extracts a small piece</strong> of a larger result</li>
</ul>
<h2 id="how-projections-work"><a class="header" href="#how-projections-work">How Projections Work</a></h2>
<h3 id="normal-flow-without-projection"><a class="header" href="#normal-flow-without-projection">Normal Flow (Without Projection)</a></h3>
<pre><code>Input changes
  ↓
Firewall recomputes (hash changes)
  ↓
All downstream marked dirty
</code></pre>
<h3 id="with-projection"><a class="header" href="#with-projection">With Projection</a></h3>
<pre><code>Input changes
  ↓
Firewall recomputes (hash changes)
  ↓
Projection recomputes (checks specific slice)
  ↓
Only if projection's result changed → mark downstream dirty
</code></pre>
<p>The projection is re-executed immediately when the firewall changes. If the projection’s specific slice hasn’t changed, dirty propagation stops.</p>
<h2 id="example-type-table"><a class="header" href="#example-type-table">Example: Type Table</a></h2>
<h3 id="firewall-query"><a class="header" href="#firewall-query">Firewall Query</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

#[derive(Debug, Clone, StableHash)]
pub struct TypeTable {
    pub types: HashMap&lt;ID, Type&gt;,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GlobalTypeTable;

impl Query for GlobalTypeTable {
    type Value = Arc&lt;TypeTable&gt;;  // Use Arc for cheap cloning

    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Firewall
    }
}
<span class="boring">}</span></code></pre>
<h3 id="projection-query"><a class="header" href="#projection-query">Projection Query</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetFunctionType {
    pub function_name: ID,
}

impl Query for GetFunctionType {
    type Value = Option&lt;Type&gt;;

    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

impl&lt;C: Config&gt; Executor&lt;GetFunctionType, C&gt; for GetFunctionTypeExecutor {
    async fn execute(
        &amp;self,
        query: &amp;GetFunctionType,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Option&lt;Type&gt; {
        // Very fast: just a hash lookup
        let table = engine.query(&amp;GlobalTypeTable).await;
        table.types.get(&amp;query.function_name).cloned()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="downstream-query-1"><a class="header" href="#downstream-query-1">Downstream Query</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct TypeCheckFunction {
    pub function_name: ID,
}

impl Query for TypeCheckFunction {
    type Value = Result&lt;(), TypeError&gt;;
}

impl&lt;C: Config&gt; Executor&lt;TypeCheckFunction, C&gt; for TypeCheckFunctionExecutor {
    async fn execute(
        &amp;self,
        query: &amp;TypeCheckFunction,
        engine: &amp;TrackedEngine&lt;C&gt;,
    ) -&gt; Result&lt;(), TypeError&gt; {
        // Depends on projection
        let function_type = engine.query(&amp;GetFunctionType {
            function_name: query.function_name.clone(),
        }).await;

        // Type check using the function's type
        type_check(function_type)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<p>When a source file changes:</p>
<ol>
<li><code>GlobalTypeTable</code> (firewall) recomputes</li>
<li>Only functions in that file have new types</li>
<li><code>GetFunctionType</code> (projection) re-executes for each dependent</li>
<li>If a specific function’s type <strong>didn’t</strong> change, its projection returns the same value</li>
<li>Most of the downstream <code>TypeCheckFunction</code> queries remain clean</li>
</ol>
<p>Result: Only functions with changed types are re-checked.</p>
<h2 id="projection-rules"><a class="header" href="#projection-rules">Projection Rules</a></h2>
<h3 id="1-only-depend-on-firewall"><a class="header" href="#1-only-depend-on-firewall">1. Only Depend on Firewall</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ GOOD - depends on firewall
impl&lt;C: Config&gt; Executor&lt;MyProjection, C&gt; for MyProjectionExecutor {
    async fn execute(&amp;self, query: &amp;MyProjection, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Value {
        let firewall_result = engine.query(&amp;MyFirewall).await;
        firewall_result.get_field()
    }
}

// ✗ BAD - depends on normal query
impl&lt;C: Config&gt; Executor&lt;BadProjection, C&gt; for BadProjectionExecutor {
    async fn execute(&amp;self, query: &amp;BadProjection, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Value {
        let normal = engine.query(&amp;NormalQuery).await;  // NOT ALLOWED!
        normal.field
    }
}
<span class="boring">}</span></code></pre>
<h3 id="2-keep-projections-fast"><a class="header" href="#2-keep-projections-fast">2. Keep Projections Fast</a></h3>
<p>Projections are re-executed during dirty propagation, so they must be very fast:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ GOOD - O(1) lookup
impl&lt;C: Config&gt; Executor&lt;FastProjection, C&gt; for FastProjectionExecutor {
    async fn execute(&amp;self, query: &amp;FastProjection, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Value {
        let table = engine.query(&amp;FirewallTable).await;
        table.get(&amp;query.key).cloned()  // Hash lookup
    }
}

// ✓ GOOD - field access
impl&lt;C: Config&gt; Executor&lt;FieldProjection, C&gt; for FieldProjectionExecutor {
    async fn execute(&amp;self, query: &amp;FieldProjection, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Value {
        let data = engine.query(&amp;FirewallData).await;
        data.field.clone()  // Direct field access
    }
}

// ✗ BAD - expensive operation
impl&lt;C: Config&gt; Executor&lt;ExpensiveProjection, C&gt; for ExpensiveProjectionExecutor {
    async fn execute(&amp;self, query: &amp;ExpensiveProjection, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Value {
        let data = engine.query(&amp;FirewallData).await;
        data.items.iter()
            .filter(|item| expensive_check(item))  // TOO SLOW!
            .collect()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="3-extract-small-slices"><a class="header" href="#3-extract-small-slices">3. Extract Small Slices</a></h3>
<p>Projections should return small portions of the firewall result:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ GOOD - returns one item
impl Query for GetItem {
    type Value = Option&lt;Item&gt;;
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

// ✓ GOOD - returns small subset
impl Query for GetItemSubset {
    type Value = Vec&lt;Item&gt;;  // Small vec
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

// ✗ BAD - returns entire result
impl Query for GetAllItems {
    type Value = Vec&lt;Item&gt;;  // Entire table!
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection  // Pointless!
    }
}
<span class="boring">}</span></code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="map-lookup"><a class="header" href="#map-lookup">Map Lookup</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetValue {
    pub key: ID,
}

impl Query for GetValue {
    type Value = Option&lt;Value&gt;;
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

impl&lt;C: Config&gt; Executor&lt;GetValue, C&gt; for GetValueExecutor {
    async fn execute(&amp;self, query: &amp;GetValue, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Option&lt;Value&gt; {
        let map = engine.query(&amp;GlobalMap).await;
        map.get(&amp;query.key).cloned()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="field-access"><a class="header" href="#field-access">Field Access</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetConfig {
    pub field: ConfigField,
}

impl Query for GetConfig {
    type Value = ConfigValue;
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

impl&lt;C: Config&gt; Executor&lt;GetConfig, C&gt; for GetConfigExecutor {
    async fn execute(&amp;self, query: &amp;GetConfig, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; ConfigValue {
        let config = engine.query(&amp;GlobalConfig).await;
        match query.field {
            ConfigField::Timeout =&gt; config.timeout,
            ConfigField::MaxRetries =&gt; config.max_retries,
            // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="index-access"><a class="header" href="#index-access">Index Access</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash, StableHash, Identifiable, Encode, Decode)]
pub struct GetArrayElement {
    pub index: usize,
}

impl Query for GetArrayElement {
    type Value = Option&lt;Element&gt;;
    fn execution_style() -&gt; ExecutionStyle {
        ExecutionStyle::Projection
    }
}

impl&lt;C: Config&gt; Executor&lt;GetArrayElement, C&gt; for GetArrayElementExecutor {
    async fn execute(&amp;self, query: &amp;GetArrayElement, engine: &amp;TrackedEngine&lt;C&gt;) -&gt; Option&lt;Element&gt; {
        let array = engine.query(&amp;GlobalArray).await;
        array.get(query.index).cloned()
    }
}
<span class="boring">}</span></code></pre>
<h2 id="performance-trade-offs"><a class="header" href="#performance-trade-offs">Performance Trade-offs</a></h2>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<ul>
<li><strong>Fine-grained invalidation</strong> - Only truly affected queries recompute</li>
<li><strong>Reduced recomputation</strong> - Could save thousands of verifications</li>
<li><strong>Composable</strong> - Build chains of projections</li>
</ul>
<h3 id="costs-1"><a class="header" href="#costs-1">Costs</a></h3>
<ul>
<li><strong>Extra executions</strong> - Projections run during dirty propagation</li>
<li><strong>More queries</strong> - Need projection queries in addition to normal queries</li>
<li><strong>Increased complexity</strong> - More query types to manage</li>
</ul>
<p>The trade-off is worth it when:</p>
<pre><code>Cost of projection re-execution &lt; Cost of recomputing downstream queries
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="persistence"><a class="header" href="#persistence">Persistence</a></h1>
<p>QBICE automatically persists query results to disk, allowing computation state to survive across program restarts. This chapter explains how persistence works and how to use it effectively.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>When you execute a query, QBICE:</p>
<ol>
<li>Computes the result</li>
<li>Serializes the key and value</li>
<li>Stores them in the database</li>
<li>Records metadata (fingerprint, timestamp, etc.)</li>
</ol>
<p>On subsequent runs:</p>
<ol>
<li>Engine loads existing data from the database</li>
<li>Cached results are available immediately</li>
<li>Only changed queries need recomputation</li>
</ol>
<h2 id="database-backends"><a class="header" href="#database-backends">Database Backends</a></h2>
<p>QBICE supports pluggable storage backends:</p>
<h3 id="rocksdb-recommended"><a class="header" href="#rocksdb-recommended">RocksDB (Recommended)</a></h3>
<p>Production-ready embedded database with excellent performance:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::storage::kv_database::rocksdb::RocksDB;

let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
    Plugin::default(),
    RocksDB::factory("/path/to/db"),
    hasher,
)?;
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Battle-tested in production</li>
<li>Excellent performance</li>
<li>Good compression</li>
<li>ACID guarantees</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Larger binary size</li>
<li>C++ dependency</li>
</ul>
<h3 id="fjall"><a class="header" href="#fjall">fjall</a></h3>
<p>Rust-native alternative:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::storage::kv_database::fjall::Fjall;

let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
    Plugin::default(),
    Fjall::factory("/path/to/db"),
    hasher,
)?;
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Pure Rust</li>
<li>Smaller binary</li>
<li>Simpler dependencies</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Less mature</li>
<li>Potentially lower performance (Could be tuned to this use case, if you are interested in helping please reach out :D )</li>
</ul>
<h2 id="database-location"><a class="header" href="#database-location">Database Location</a></h2>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<p>Use temporary directories for testing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tempfile::tempdir;

let temp_dir = tempdir()?;
let mut engine = Engine::&lt;DefaultConfig&gt;::new_with(
    Plugin::default(),
    RocksDB::factory(temp_dir.path()),
    hasher,
)?;

// Database deleted when temp_dir is dropped
<span class="boring">}</span></code></pre>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Query keys and values must implement <code>Encode</code> and <code>Decode</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qbice::{Encode, Decode};

#[derive(
    Debug, Clone, PartialEq, Eq, Hash,
    StableHash, Identifiable,
    Encode, Decode,  // Required for persistence
)]
pub struct MyQuery {
    pub id: u64,
    pub name: String,
}

#[derive(Debug, Clone, StableHash, Encode, Decode)]
pub struct MyValue {
    pub result: String,
    pub metadata: Metadata,
}
<span class="boring">}</span></code></pre>
<h3 id="custom-serialization"><a class="header" href="#custom-serialization">Custom Serialization</a></h3>
<p>For types that don’t implement <code>Encode/Decode</code>, wrap them or use newtype pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, StableHash)]
pub struct MyValue {
    pub data: ThirdPartyType,  // Doesn't implement Encode/Decode
}

// Implement manual serialization
impl Encode for MyValue {
    fn encode&lt;E: Encoder + ?Sized&gt;(
        &amp;self,
        encoder: &amp;mut E,
        plugin: &amp;Plugin,
        session: &amp;mut Session,
    ) -&gt; std::io::Result&lt;()&gt; {
        // Custom encoding logic
    }
}

impl Decode for MyValue {
    fn decode&lt;D: Decoder + ?Sized&gt;(
        decoder: &amp;mut D,
        plugin: &amp;Plugin,
        session: &amp;mut Session,
    ) -&gt; std::io::Result&lt;Self&gt; {
        // Custom decoding logic
    }
}
<span class="boring">}</span></code></pre>
<h2 id="schema-evolution"><a class="header" href="#schema-evolution">Schema Evolution</a></h2>
<p>Generally, we provide no guarantees for schema between versions at all. If you
change the structure of your queries or values, you must clear the database to
avoid runtime panics.</p>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>Currently, QBICE still doesn’t provide built-in garbage collection for the
database. We plan to add this feature in the future.</p>
<p>We imagine that users will specify nodes where you normally use it, and QBICE
will periodically clean up unreachable entries from the database.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="engine"><a class="header" href="#engine">Engine</a></h3>
<p>The central database that manages query execution, result caching, and dependency tracking. The <code>Engine</code> stores computed values, tracks dependencies between queries, and coordinates executor execution.</p>
<h3 id="trackedengine"><a class="header" href="#trackedengine">TrackedEngine</a></h3>
<p>A lightweight wrapper around the <code>Engine</code> that tracks dependencies during query execution. Created from <code>Arc&lt;Engine&gt;</code> via the <code>tracked()</code> method. Provides the <code>query()</code> method for executing queries.</p>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<p>A type representing a computation’s input (key) and output (value). Implements the <code>Query</code> trait. Each unique query instance represents a distinct computation. The query itself only defines <em>what</em> to compute, not <em>how</em>.</p>
<h3 id="executor"><a class="header" href="#executor">Executor</a></h3>
<p>Implements the <code>Executor</code> trait to define <em>how</em> to compute a value for a specific query type. Executors contain the actual computation logic and can depend on other queries through the <code>TrackedEngine</code>.</p>
<h3 id="query-key"><a class="header" href="#query-key">Query Key</a></h3>
<p>The query instance itself, which serves as the input to the computation. Different field values create different query keys, representing different computations.</p>
<h3 id="query-value"><a class="header" href="#query-value">Query Value</a></h3>
<p>The output of a query computation. Defined by the <code>Value</code> associated type in the <code>Query</code> trait implementation.</p>
<h3 id="query-id"><a class="header" href="#query-id">Query ID</a></h3>
<p>A unique identifier for each query instance, combining a stable type identifier and a 128-bit hash of the query’s contents.</p>
<h2 id="dependency-tracking"><a class="header" href="#dependency-tracking">Dependency Tracking</a></h2>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<p>The directed graph of query dependencies, where nodes are queries and edges represent “depends on” relationships. QBICE automatically builds this graph during query execution.</p>
<h3 id="forward-edge"><a class="header" href="#forward-edge">Forward Edge</a></h3>
<p>An edge from a query to its dependencies (callees). Stores the last seen fingerprint of the dependency for change detection.</p>
<h3 id="backward-edge"><a class="header" href="#backward-edge">Backward Edge</a></h3>
<p>An edge from a query to its dependents (callers). Used for dirty propagation.</p>
<h3 id="dirty-flag"><a class="header" href="#dirty-flag">Dirty Flag</a></h3>
<p>A boolean flag indicating whether a query’s result may be invalid due to changes in its dependencies. Queries marked dirty need verification before their cached result can be used.</p>
<h3 id="dirty-propagation"><a class="header" href="#dirty-propagation">Dirty Propagation</a></h3>
<p>The process of marking queries as dirty when their dependencies change. Propagates upward through backward edges from changed inputs to dependent queries.</p>
<h3 id="fingerprint"><a class="header" href="#fingerprint">Fingerprint</a></h3>
<p>A 128-bit hash of a query’s result, used for change detection. When a dependency is recomputed, its fingerprint is compared to the previously seen fingerprint to determine if the dependent needs recomputation.</p>
<h3 id="verification-timestamp"><a class="header" href="#verification-timestamp">Verification Timestamp</a></h3>
<p>A timestamp indicating when a query was last verified to be up-to-date. Used to avoid redundant verification checks.</p>
<h2 id="execution-styles"><a class="header" href="#execution-styles">Execution Styles</a></h2>
<h3 id="normal-query"><a class="header" href="#normal-query">Normal Query</a></h3>
<p>The standard execution style with full dependency tracking. Most queries should use this style.</p>
<h3 id="external-input"><a class="header" href="#external-input">External Input</a></h3>
<p>Marks a query as an input value set via input sessions. These queries should never be executed—their values are provided directly.</p>
<h3 id="firewall-query-1"><a class="header" href="#firewall-query-1">Firewall Query</a></h3>
<p>An advanced optimization that prevents dirty propagation from crossing the query boundary. Only propagates dirtiness to dependents if the firewall’s computed value actually changes. Used to limit excessive dirty propagation at chokepoints.</p>
<h3 id="projection-query-1"><a class="header" href="#projection-query-1">Projection Query</a></h3>
<p>A fast query that extracts a specific slice of data from a firewall or projection query result. Must be very fast to execute (e.g., hash lookup, field access). Provides fine-grained change detection for large firewall results.</p>
<h3 id="transitive-firewall-edge"><a class="header" href="#transitive-firewall-edge">Transitive Firewall Edge</a></h3>
<p>A special dependency edge that allows queries to directly check firewall queries they transitively depend on. Ensures correctness when firewall queries block normal dirty propagation.</p>
<h2 id="execution-flow"><a class="header" href="#execution-flow">Execution Flow</a></h2>
<h3 id="repairation"><a class="header" href="#repairation">Repairation</a></h3>
<p>The lazy process of verifying and recomputing queries when they’re requested. Checks dependencies, compares fingerprints, and re-executes only if necessary.</p>
<h3 id="incremental-computation"><a class="header" href="#incremental-computation">Incremental Computation</a></h3>
<p>The process of recomputing only what’s necessary when inputs change, by tracking dependencies and using cached results for unchanged queries.</p>
<h3 id="cache-hit"><a class="header" href="#cache-hit">Cache Hit</a></h3>
<p>When a query’s cached result can be returned without re-execution because nothing has changed.</p>
<h3 id="cache-miss"><a class="header" href="#cache-miss">Cache Miss</a></h3>
<p>When a query must be re-executed because it’s dirty or has never been computed.</p>
<h3 id="cycle"><a class="header" href="#cycle">Cycle</a></h3>
<p>A situation where a query depends on itself, either directly or transitively. QBICE automatically detects cycles and reports an error.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<h3 id="persistence-1"><a class="header" href="#persistence-1">Persistence</a></h3>
<p>The automatic saving of query results to disk, allowing computation state to survive across program restarts.</p>
<h3 id="database-backend"><a class="header" href="#database-backend">Database Backend</a></h3>
<p>The pluggable key-value store used for persisting query results. QBICE supports RocksDB and fjall.</p>
<h3 id="serialization-1"><a class="header" href="#serialization-1">Serialization</a></h3>
<p>The process of converting query keys and values to bytes for storage. Implemented via the <code>Encode</code> and <code>Decode</code> traits.</p>
<h3 id="stable-hash"><a class="header" href="#stable-hash">Stable Hash</a></h3>
<p>A hash function that produces consistent results across program runs. Required for queries to ensure persistence works correctly.</p>
<h3 id="hasher-seed"><a class="header" href="#hasher-seed">Hasher Seed</a></h3>
<p>A value used to initialize the stable hasher. Must be consistent across runs for cached results to match.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="config-trait"><a class="header" href="#config-trait">Config Trait</a></h3>
<p>A trait for customizing QBICE’s behavior. Most users should use <code>DefaultConfig</code>.</p>
<h3 id="plugin"><a class="header" href="#plugin">Plugin</a></h3>
<p>Handles serialization and deserialization of query keys and values. The default plugin works for types implementing <code>Encode</code> and <code>Decode</code>.</p>
<h3 id="input-session"><a class="header" href="#input-session">Input Session</a></h3>
<p>A transaction-like mechanism for setting input query values. Changes are batched and committed when the session is dropped, triggering dirty propagation.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="chokepoint"><a class="header" href="#chokepoint">Chokepoint</a></h3>
<p>A query with many dependents that acts as a bottleneck for dirty propagation. Good candidates for firewall queries.</p>
<h3 id="over-invalidation"><a class="header" href="#over-invalidation">Over-Invalidation</a></h3>
<p>When queries are marked dirty even though their specific dependencies haven’t changed. Solved by projection queries.</p>
<h3 id="local-cache"><a class="header" href="#local-cache">Local Cache</a></h3>
<p>A cache maintained by each <code>TrackedEngine</code> instance for the current execution context. Ensures repeated queries within the same context return instantly.</p>
<h3 id="global-cache"><a class="header" href="#global-cache">Global Cache</a></h3>
<p>The engine’s persistent cache of computed query results, shared across all <code>TrackedEngine</code> instances.</p>
<h2 id="related-concepts"><a class="header" href="#related-concepts">Related Concepts</a></h2>
<h3 id="memoization"><a class="header" href="#memoization">Memoization</a></h3>
<p>Caching function results based on their inputs. QBICE provides automatic, incremental memoization with dependency tracking.</p>
<h3 id="dataflow-programming"><a class="header" href="#dataflow-programming">Dataflow Programming</a></h3>
<p>A programming paradigm where programs are modeled as directed graphs of data flowing between operations. QBICE enables dataflow-style programming with automatic incremental updates.</p>
<h3 id="salsa-1"><a class="header" href="#salsa-1">Salsa</a></h3>
<p>An inspiration for QBICE. A Rust framework for on-demand, incrementalized computation.</p>
<h3 id="adapton-1"><a class="header" href="#adapton-1">Adapton</a></h3>
<p>Another inspiration for QBICE. A library for incremental computing with explicit dependency tracking.</p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#introduction">Introduction</a> - Overview of QBICE</li>
<li><a href="#getting-started">Getting Started</a> - Tutorial introduction</li>
<li><a href="reference/engine.html">Engine</a> - Engine reference</li>
<li><a href="reference/query.html">Query</a> - Query trait reference</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
